---
import Base from "../layouts/Base.astro";

const canonical = "https://freeperlcode.com/regex";
---

<Base
  title="Perl Regular Expressions - Complete Guide"
  description="Master Perl regex with practical examples. Learn pattern matching, substitutions, capture groups, and advanced text processing."
  canonical={canonical}
>
  <section class="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-12 prose prose-lg dark:prose-invert">
    <h1>Perl Regular Expressions: The Complete Guide</h1>

    <p>
      Perl's regex engine is legendary. For over 35 years, it has been the gold standard for
      pattern matching, inspiring regex implementations in Python, JavaScript, Java, and countless
      other languages. This guide shows you how to use Perl regex effectively in real-world
      text processing tasks.
    </p>

    <h2>Why Perl Regex is Different</h2>

    <p>
      Unlike other languages where regex is an add-on library, Perl integrates regular expressions
      directly into the language syntax. This integration makes regex operations concise, readable,
      and powerful. The regex operators (<code>=~</code> for matching, <code>!~</code> for
      non-matching) work seamlessly with Perl's control structures.
    </p>

    <h2>The Basic Matching Operator</h2>

    <p>
      The match operator searches a string for a pattern. You can bind it to any variable using
      the binding operator <code>=~</code>.
    </p>

    <p><strong>Basic matching examples:</strong></p>
    <ul>
      <li><code>$text =~ /Perl/</code> - Matches if text contains "Perl"</li>
      <li><code>$text =~ /perl/i</code> - Case-insensitive match with <code>/i</code> modifier</li>
      <li><code>$text !~ /Python/</code> - True if text does NOT contain "Python"</li>
    </ul>

    <h2>Character Classes</h2>

    <p>
      Character classes let you match any character from a set. Perl provides predefined classes
      for common patterns.
    </p>

    <h3>Predefined Character Classes</h3>

    <table class="min-w-full divide-y divide-gray-200 dark:divide-dark-700">
      <thead class="bg-gray-50 dark:bg-dark-800">
        <tr>
          <th class="px-4 py-2 text-left">Class</th>
          <th class="px-4 py-2 text-left">Matches</th>
          <th class="px-4 py-2 text-left">Negation</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>\d</code></td>
          <td>Digits [0-9]</td>
          <td><code>\D</code> - non-digits</td>
        </tr>
        <tr>
          <td><code>\w</code></td>
          <td>Word characters [a-zA-Z0-9_]</td>
          <td><code>\W</code> - non-word</td>
        </tr>
        <tr>
          <td><code>\s</code></td>
          <td>Whitespace [ \t\n\r\f]</td>
          <td><code>\S</code> - non-whitespace</td>
        </tr>
      </tbody>
    </table>

    <h3>Custom Character Classes</h3>
    <ul>
      <li><code>[aeiou]</code> - Matches any vowel</li>
      <li><code>[^aeiou]</code> - Matches any non-vowel (caret negates)</li>
      <li><code>[a-zA-Z]</code> - Matches any letter</li>
      <li><code>[0-9a-fA-F]</code> - Matches hexadecimal digits</li>
    </ul>

    <h2>Quantifiers</h2>

    <p>
      Quantifiers specify how many times a pattern should match. Understanding greedy vs non-greedy
      matching is crucial for correct regex behavior.
    </p>

    <table class="min-w-full divide-y divide-gray-200 dark:divide-dark-700">
      <thead class="bg-gray-50 dark:bg-dark-800">
        <tr>
          <th class="px-4 py-2 text-left">Quantifier</th>
          <th class="px-4 py-2 text-left">Meaning</th>
          <th class="px-4 py-2 text-left">Example</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>*</code></td>
          <td>0 or more times</td>
          <td><code>/a*/</code> matches "", "a", "aa", "aaa"...</td>
        </tr>
        <tr>
          <td><code>+</code></td>
          <td>1 or more times</td>
          <td><code>/a+/</code> matches "a", "aa", "aaa"...</td>
        </tr>
        <tr>
          <td><code>?</code></td>
          <td>0 or 1 time (optional)</td>
          <td><code>/a?/</code> matches "" or "a"</td>
        </tr>
        <tr>
          <td><code>{n}</code></td>
          <td>Exactly n times</td>
          <td><code>/a{3}/</code> matches "aaa"</td>
        </tr>
        <tr>
          <td><code>{n,m}</code></td>
          <td>n to m times</td>
          <td><code>/a{2,4}/</code> matches "aa", "aaa", "aaaa"</td>
        </tr>
        <tr>
          <td><code>*?</code></td>
          <td>0 or more (non-greedy)</td>
          <td>Stops at first match</td>
        </tr>
      </tbody>
    </table>

    <h2>Capture Groups</h2>

    <p>
      Capture groups let you extract parts of a match. Parentheses create capturing groups,
      and you reference the captured content with <code>$1</code>, <code>$2</code>, etc.
    </p>

    <p><strong>Examples:</strong></p>
    <ul>
      <li><code>if ($text =~ /(\d{4})-(\d{2})-(\d{2})/)</code> - Captures year, month, day as <code>$1</code>, <code>$2</code>, <code>$3</code></li>
      <li><code>$&</code> - The entire matched string</li>
      <li><code>$`</code> - Text before the match</li>
      <li><code>$'</code> - Text after the match</li>
    </ul>

    <h2>Substitutions with s///</h2>

    <p>
      The substitution operator finds and replaces text. The basic syntax is
      <code>s/pattern/replacement/modifiers</code>.
    </p>

    <p><strong>Common substitutions:</strong></p>
    <ul>
      <li><code>$text =~ s/foo/bar/</code> - Replace first "foo" with "bar"</li>
      <li><code>$text =~ s/foo/bar/g</code> - Global replacement (all occurrences)</li>
      <li><code>$text =~ s/foo/bar/i</code> - Case-insensitive replacement</li>
      <li><code>$text =~ s/\s+/ /g</code> - Replace multiple whitespace with single space</li>
      <li><code>$name =~ s/(\w+),\s+(\w+)/$2 $1/</code> - Swap "Last, First" to "First Last"</li>
    </ul>

    <h2>Useful Regex Modifiers</h2>

    <table class="min-w-full divide-y divide-gray-200 dark:divide-dark-700">
      <thead class="bg-gray-50 dark:bg-dark-800">
        <tr>
          <th class="px-4 py-2 text-left">Modifier</th>
          <th class="px-4 py-2 text-left">Effect</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>/i</code></td>
          <td>Case-insensitive matching</td>
        </tr>
        <tr>
          <td><code>/g</code></td>
          <td>Global (find all matches)</td>
        </tr>
        <tr>
          <td><code>/m</code></td>
          <td>Multi-line mode (^ and $ match per line)</td>
        </tr>
        <tr>
          <td><code>/s</code></td>
          <td>Single-line mode (.) matches newlines</td>
        </tr>
        <tr>
          <td><code>/x</code></td>
          <td>Allow whitespace and comments in pattern</td>
        </tr>
        <tr>
          <td><code>/e</code></td>
          <td>Evaluate replacement as code</td>
        </tr>
      </tbody>
    </table>

    <h2>Practical Examples</h2>

    <h3>Email Validation</h3>
    <p>
      Basic email pattern: <code>/^[\w.-]+@[\w.-]+\.[a-zA-Z]{2,}$/</code>
    </p>

    <h3>URL Extraction</h3>
    <p>
      Find URLs: <code>/(https?:\/\/[\w\-\.~:\/?#\[\]@!\$&'()*+,;=]+)/g</code>
    </p>

    <h3>Log Parsing</h3>
    <p>
      Parse Apache log format to extract IP, timestamp, method, path, status, and bytes.
    </p>

    <h2>Advanced Features</h2>

    <h3>Lookahead Assertions</h3>
    <ul>
      <li><code>(?=pattern)</code> - Positive lookahead: match only if followed by pattern</li>
      <li><code>(?!pattern)</code> - Negative lookahead: match only if NOT followed by pattern</li>
    </ul>

    <h3>Lookbehind Assertions</h3>
    <ul>
      <li><code>(?<=pattern)</code> - Positive lookbehind: match only if preceded by pattern</li>
      <li><code>(?<!pattern)</code> - Negative lookbehind: match only if NOT preceded by pattern</li>
    </ul>

    <h3>Named Capture Groups (Perl 5.10+)</h3>
    <p>
      Instead of <code>$1</code>, <code>$2</code>, use descriptive names:
      <code>/(?<name>\w+):\s+(?<age>\d+)/</code> then access via <code>$+{name}</code>
    </p>

    <h2>Common Patterns Reference</h2>

    <table class="min-w-full divide-y divide-gray-200 dark:divide-dark-700">
      <thead class="bg-gray-50 dark:bg-dark-800">
        <tr>
          <th class="px-4 py-2 text-left">Pattern</th>
          <th class="px-4 py-2 text-left">Matches</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>^\d+$</code></td>
          <td>Whole positive integer</td>
        </tr>
        <tr>
          <td><code>^\w+@\w+\.\w+</code></td>
          <td>Simple email format</td>
        </tr>
        <tr>
          <td><code>^https?://</code></td>
          <td>HTTP or HTTPS URL</td>
        </tr>
        <tr>
          <td><code>^\d{3}-\d{2}-\d{4}$</code></td>
          <td>SSN format</td>
        </tr>
        <tr>
          <td><code>^\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}$</code></td>
          <td>US phone number</td>
        </tr>
      </tbody>
    </table>

    <h2>Perl One-Liners</h2>

    <p>
      Perl's command-line mode makes regex operations incredibly convenient:
    </p>

    <ul>
      <li><code>perl -ne 'print if /error/i' logfile.txt</code> - Find lines with "error"</li>
      <li><code>perl -ne 'print if $. >= 50 && $. <= 60' file.txt</code> - Print lines 50-60</li>
      <li><code>perl -i -pe 's/foo/bar/g' *.txt</code> - Replace in all files</li>
      <li><code>perl -F, -ane '$sum += $F[2]; END { print $sum }' data.csv</code> - Sum column 3</li>
    </ul>

    <h2>Learn More</h2>

    <p>
      Perl's regex capabilities go far beyond what's covered here. For deeper dives into specific
      patterns and techniques, explore our question database:
    </p>

    <ul>
      <li><a href="/search">Search</a> for specific regex patterns</li>
      <li><a href="/topics/regex">Regex topics</a> for categorized tutorials</li>
      <li><a href="/questions">All questions</a> for regex examples</li>
    </ul>

    <p>
      Remember: Perl regex is powerful, but with great power comes responsibility. Always test your
      patterns with edge cases, use <code>use strict;</code> and <code>use warnings;</code>, and
      consider readability when writing complex regex.
    </p>
  </section>
</Base>
